import "cosmo.h" as cosmo
include "sys/utsname.h"
include "sys/stat.h"
import "std/process.zc"
import "std/slice.zc"
import "std/string.zc"
import "std/path.zc"
import "std/fs.zc"
import "std/result.zc"
import "std/option.zc"

enum OsKind {
    Windows,
    MacOs,
    Linux,
    FreeBsd,
    OpenBsd,
    NetBsd,
    Unknown
}

// TODO: zen c currently doesn't have Rust-style `let EnumValue1(enum_value_1) = some_enum` pattern matching,
//       so im just writing helper functions for enums
impl OsKind {
    fn is_unix(self) -> bool {
        match *self {
            OsKind::Windows => { return false },
            OsKind::Unknown => { return false },
            _ => { return true },
        }
    }

    fn is_linux(self) -> bool {
        match *self {
            OsKind::Linux => { return true },
            _ => { return false },
        }
    }

    fn is_windows(self) -> bool {
        match *self {
            OsKind::Windows => { return true },
            _ => { return false },
        }
    }

    fn to_string(self) -> string {
        match *self {
            OsKind::Windows => { return "Windows" },
            OsKind::MacOs => { return "macOS" },
            OsKind::Linux => { return "Linux" },
            OsKind::FreeBsd => { return "FreeBSD" },
            OsKind::OpenBsd => { return "OpenBSD" },
            OsKind::NetBsd => { return "NetBSD" },
            OsKind::Unknown => { return "Unknown" },
        }  
    }
}

enum OsArchKind {
    x86_64,
    aarch64,
    Unknown
}

// TODO: zen c currently doesn't have Rust-style `let EnumValue1(enum_value_1) = some_enum` pattern matching,
//       so im just writing helper functions for enums
impl OsArchKind {
    fn is_x86_64(self) -> bool {
        match *self {
            OsArchKind::x86_64 => { return true },
            _ => { return false },
        }
    }

    fn is_aarch64(self) -> bool {
        match *self {
            OsArchKind::aarch64 => { return true },
            _ => { return false },
        }
    }

    fn to_string(self) -> string {  
        match *self {  
            OsArchKind::x86_64 => { return "x86_64" },  
            OsArchKind::aarch64 => { return "aarch64" },  
            OsArchKind::Unknown => { return "Unknown" },  
        }  
    }
}

fn get_path_parent(path: const string) -> String {
    autofree let s = String::from(path)

    let last_sep: isize = -1
    let i: usize = 0
    while i < s.length() {
        let c = path[i]
        // paths on windows is normalized to unix-style by cosmopolitan, so only '/'
        if c == '/' {
            last_sep = (isize)i
        }
        i = i + 1
    }

    if last_sep < 0 {
        return String::from("")
    }

    return s.substring(0, (usize)last_sep)
}

fn exe_ret_success(exe_name: const string, args: Slice<string>) -> bool {
    let cmd = Command::new(exe_name)
    for arg in args {
        cmd.arg(arg)
    }
    return cmd.status() == 0
}

fn write_bytes_to_file(bytes: u8[], path: const string) -> bool {
    let fp: FILE* = fopen(path, "wb")
    if fp == 0 {
        !"error: failed to open file for writing"
        return false
    }

    if bytes.data != 0 && bytes.len > 0 {
        if fwrite(bytes.data, sizeof(u8), bytes.len, fp) != (usize)bytes.len {
            !"error: failed to write 'data' array to file"
            fclose(fp)
            return false
        }
    }

    if fclose(fp) == EOF {
        !"error: failed to close file after writing"
        return false
    }

    return true
}

fn create_dir(path: const string) -> bool {
    if !File::exists(path) {
        let result = File::create_dir(path)
        if result.is_err() || !result.unwrap() {
            return false
        }
        return true
    }

    let meta_result = File::metadata(path)
    if meta_result.is_err() || !meta_result.unwrap().is_dir {
        !"warning: found file instead of dir, removing..."
        let result = File::remove_file(path)
        if result.is_err() || !result.unwrap() {
            !"error: failed to remove file"
            return false
        }
        // try creating again
        return create_dir(path)
    }
    return true
}

fn get_current_os_kind() -> OsKind {
    let os_kind = OsKind::Unknown()
    if cosmo::IsWindows() {
        os_kind = OsKind::Windows()
    } else if (cosmo::IsXnu()) {
        os_kind = OsKind::MacOs()
    } else if (cosmo::IsLinux()) {
        os_kind = OsKind::Linux()
    } else if (cosmo::IsFreebsd()) {
        os_kind = OsKind::FreeBsd()
    } else if (cosmo::IsOpenbsd()) {
        os_kind = OsKind::OpenBsd()
    } else if (cosmo::IsNetbsd()) {
        os_kind = OsKind::NetBsd()
    } else {
        os_kind = OsKind::Unknown()
    }
    return os_kind
}

fn get_current_os_arch_kind() -> OsArchKind {
    let is_x86_64 = false
    let is_aarch64 = false
    let uname_success = false

    raw {
        struct utsname uname_info;
        if (uname(&uname_info) == 0) {
            uname_success = true;
            if (strcmp(uname_info.machine, "x86_64") == 0) {
                is_x86_64 = true;
            } else if (strcmp(uname_info.machine, "aarch64") == 0) {
                is_aarch64 = true;
            }
        }
    }

    if !uname_success {
        !"error: failed to get uname info"
        return OsArchKind::Unknown()
    }

    if is_x86_64 {
        return OsArchKind::x86_64()
    }
    
    if is_aarch64 {
        return OsArchKind::aarch64()
    }

    return OsArchKind::Unknown()
}

fn ensure_working_dir() {
    let cur_file_cstr: const string = cosmo::GetProgramExecutableName()
    "debug: current exe file: {cur_file_cstr}"
    // TODO: zen c's Path::parent() seems broken, so using my own impl for now
    
    // let cur_file_path = Path::new(cur_file_cstr)
    // let cur_dir_cstr = cur_file_path.parent()
    //     .expect("error: couldnt determine current exe dir")
    //     .c_str()
    autofree let cur_dir_str: const String = get_path_parent(cur_file_cstr)
    let cur_dir_cstr: const string = cur_dir_str.c_str()
    
    if cur_dir_cstr == "" {
        !"error: couldnt determine current exe dir"
        exit(1)
    }
    "debug: current exe dir: {cur_dir_cstr}"
    chdir(cur_dir_cstr)
    "debug: changed working dir to exe dir"
}

fn main() {
    // embedded files
    let mke2fs_win_bytes = embed "../e2fsprogs/dist/mke2fs.com" as u8[]
    let debugfs_win_bytes = embed "../e2fsprogs/dist/debugfs.com" as u8[]
    let rkdevtool_linux_bytes = embed "../rkdeveloptool-rs/target/release/rkdeveloptool-rs" as u8[]
    let rkdevtool_win_bytes = embed "../rkdeveloptool-rs/target/x86_64-pc-windows-gnu/release/rkdeveloptool-rs.exe" as u8[]
    let startup_script_bytes = embed "./startup_script.sh" as u8[]

    // 0. welcome
    "--- welcome to the one-click youdao dictionary pen cracking tool ---"
    "             --- by: Fey Xie <feyxiexzf@gmail.com> ---              "
    ""

    // 1. get basic os info

    // 1a. os
    let os_kind = get_current_os_kind()
    "debug: current os kind is {os_kind.to_string()}"

    // 1b. os arch
    let os_arch_kind = get_current_os_arch_kind()
    "debug: current os arch kind is {os_arch_kind.to_string()}"

    // 2. extract embedded files if needed
    ensure_working_dir()
    if !create_dir("res") {
        !"error: failed to create res dir for extracting embedded resources"
        return 1
    }

    // 2a. e2fsprogs
    let mke2fs_path = ""
    let debugfs_path = ""
    if os_kind.is_unix() {
        "info: os is unix, assuming that e2fsprogs is available"
        mke2fs_path = "mke2fs"
        debugfs_path = "debugfs"   
    }
    else {
        "info: os is windows, extracting embedded pre-compiled e2fsprogs..."

        if write_bytes_to_file(mke2fs_win_bytes, "res/mke2fs.com") {
            "info: wrote mke2fs exe"
            mke2fs_path = "res/mke2fs.com"
        }
        else {
            !"error: failed to write mke2fs exe"
            return 1
        }

        if write_bytes_to_file(debugfs_win_bytes, "res/debugfs.com") {
            "info: wrote debugfs exe"
            debugfs_path = "res/debugfs.com"
        }
        else {
            !"error: failed to write debugfs exe"
            return 1
        }
    }

    // 2b. rkdeveloptool
    let rkdevtool_path = ""
    if os_kind.is_unix() {
        if File::exists("res/rkdeveloptool") {
            "info: found rkdeveloptool in res dir, using that"
            rkdevtool_path = "res/rkdeveloptool"
        }
        else {
            !"warning: rkdeveloptool not found in res dir, searching in PATH..."
            let chk_rkdevtool_exist_args = ["-v", "rkdeveloptool"]
            if exe_ret_success("command", Slice<string>::from_array(chk_rkdevtool_exist_args, 2)) {
                "info: found rkdeveloptool in PATH, using that"
                rkdevtool_path = "rkdeveloptool"
            }
            else {
                !"warning: rkdeveloptool not found in PATH, extracting embedded pre-compiled binary..."
                if os_kind.is_linux() {
                    if write_bytes_to_file(rkdevtool_linux_bytes, "res/rkdeveloptool") {
                        "info: wrote rkdeveloptool exe, using that"
                        rkdevtool_path = "res/rkdeveloptool"
                        let chmod_rkdevtool_args = ["755", "res/rkdeveloptool"]
                        if exe_ret_success("chmod", Slice<string>::from_array(chmod_rkdevtool_args, 2)) {
                            "info: added execution permission on res/rkdeveloptool"
                        }
                        else {
                            !"error: failed to add execution permission on res/rkdeveloptool"
                            return 1
                        }
                    }
                    else {
                        !"error: failed to write rkdeveloptool exe"
                        return 1
                    }
                }
                else {
                    !"error: os is unix but not linux"
                    !"       prebuilt binaries are only provided for linux"
                    !"       please please build/download rkdeveloptool yourself and put it in res/rkdeveloptool"
                    return 1
                }
            }
        }
    }
    else {
        if File::exists("res/rkdeveloptool.exe") {
            "info: found rkdeveloptool in res dir, using that"
            rkdevtool_path = "res/rkdeveloptool.exe"
        }
        else {
            // not gonna search for rkdevtool in PATH on windows since PATH is basically useless there
            !"warning: rkdeveloptool not found in res dir, extracting embedded pre-compiled binary..."
            if !os_arch_kind.is_x86_64() {
                !"warning: os arch is not x86_64, will run rkdeveloptool under system compatability layer"
                "         rkdeveloptool may not work properly. if that's the case,"
                "         please build/download rkdeveloptool yourself and put it in res/rkdeveloptool.exe"
            }

            if write_bytes_to_file(rkdevtool_win_bytes, "res/rkdeveloptool.exe") {
                "info: wrote rkdeveloptool exe, using that"
                rkdevtool_path = "res/rkdeveloptool.exe"
            }
            else {
                !"error: failed to write rkdeveloptool exe"
                return 1
            }
        }
    }

    // 3. create image
    if os_kind.is_unix() {
        let dd_args = ["if=/dev/zero", "of=userdisk.img", "bs=1M", "count=1024"]
        if exe_ret_success("dd", Slice<string>::from_array(dd_args, 4)) {
            "info: successfully created 1GiB userdisk.img"
        }
        else {
            !"error: failed to create image"
            return 1
        }
    }
    else {
        let fsutil_args = ["file", "createnew", "userdisk.img", "1073741824"]
        if exe_ret_success("fsutil", Slice<string>::from_array(fsutil_args, 4)) {
            "info: successfully created 1GiB userdisk.img"
        }
        else {
            !"error: failed to create image"
            return 1
        }
    }

    // 4. create filesystem
    let mke2fs_args = ["-F", "-L", "userdisk", "-O", "^has_journal,^metadata_csum,^64bit", "-m", "0", "userdisk.img"]
    if exe_ret_success(mke2fs_path, Slice<string>::from_array(mke2fs_args, 8)) {
        "info: successfully created ext4 filesystem on userdisk.img"
    }
    else {
        !"error: failed to create filesystem on image"
        return 1
    }

    // 5. save script
    if write_bytes_to_file(startup_script_bytes, "res/startup_script.sh") {
        "info: saved startup script locally"
    }
    else {
        !"error: failed to wrote startup script locally"
        return 1
    }

    // 6. add script into image
    // FIXME: zen c struggles to transpile this, resulting to re-definition of struct Slice<string>
    // let debugfs_args_1 = ["-w", "-R", "mkdir /skip_re", "userdisk.img"]
    // let debugfs_args_2 = ["-w", "-R", "write res/startup_script.sh /skip_re/skip_login.sh", "userdisk.img"]
    // let debugfs_args_3 = ["-w", "-R", "sif /skip_re/skip_login.sh mode 0100755", "userdisk.img"]
    // let debugfs_args_list = [
    //     Slice<string>::from_array(debugfs_args_1, 4),
    //     Slice<string>::from_array(debugfs_args_2, 4),
    //     Slice<string>::from_array(debugfs_args_3, 4)
    // ]
    // FIXME: zen c is so confused that it even couldnt transpile this correctly
    // let debugfs_args_list = [
    //     ["-w", "-R", "mkdir /skip_re", "userdisk.img"],
    //     ["-w", "-R", "write res/startup_script.sh /skip_re/skip_login.sh", "userdisk.img"],
    //     ["-w", "-R", "sif /skip_re/skip_login.sh mode 0100755", "userdisk.img"]
    // ]
    // for debugfs_args in debugfs_args_list {
    //     let args_slice = Slice<string>::from_array(debugfs_args, 4)
    //     if exe_ret_success(debugfs_path, args_slice) {
    //         "info: successfully manipulated image"
    //     }
    //     else {
    //         !"error: failed to manipulate image"
    //         return 1
    //     }
    // }
    let debugfs_args_1 = ["-w", "-R", "\"mkdir", "/skip_re\"", "userdisk.img"]
    let debugfs_args_2 = ["-w", "-R", "\"write", "res/startup_script.sh", "/skip_re/skip_login.sh\"", "userdisk.img"]
    let debugfs_args_3 = ["-w", "-R", "\"sif", "/skip_re/skip_login.sh", "mode", "0100755\"", "userdisk.img"]
    if exe_ret_success(debugfs_path, Slice<string>::from_array(debugfs_args_1, 5)) {
        "info: successfully manipulated image [1/3]"
    }
    if exe_ret_success(debugfs_path, Slice<string>::from_array(debugfs_args_2, 6)) {
        "info: successfully manipulated image [2/3]"
    }
    if exe_ret_success(debugfs_path, Slice<string>::from_array(debugfs_args_3, 7)) {
        "info: successfully manipulated image [3/3]"
    }

    // 7. upload image to device
    "info: image prepared successfully"
    "      about to upload image to device"
    ""
    "      please:"
    "      1. shutdown the device"
    "      2. hold the home button for ~1.5 seconds"
    "      3. plug the device into your pc"
    "      4. release the home button"
    ""
    "      note:"
    "      if upload fails, you probably need to run this with sudo/as administrator"
    ""
    "      to confirm, enter 'yes' below"
    let confirm_input = "";
    ? "prompt: confirm to upload image to device? (yes/no) " (confirm_input);
    if confirm_input != "yes" {
        "info: ok canceled"
        return 1
    }
    let rkdevtool_args = ["wlx", "userdisk", "userdisk.img"]
    if exe_ret_success(rkdevtool_path, Slice<string>::from_array(rkdevtool_args, 3)) {
        "info: successfully uploaded image"
    }
    else {
        !"error: failed to upload image; read the notes above for possible solutions"
        return 1
    }

    // 8. post-installation
    "info: your device should now be cracked!"
    "      long-press power button to reboot it"
    "      click on the 'about -> legal regulatory' page in device settings for 5 times to enable usb access"
    "      then, after you acquire the adb shell,"
    "      execute 'resize2fs /userdisk' inside to restore stock partition size"
}
